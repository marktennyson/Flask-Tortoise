{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Flask-Tortoise - Asynchronous database support for Flask \u00b6 Documentation: https://navycut.github.io Github Repo: https://github.com/navycut/navycut Introduction \u00b6 Flask-Tortoise is an extension for Flask that adds support for asynchronous Tortoise-ORM to your application with in-built migration system. It aims to simplify using Tortoise-ORM with Flask by providing useful defaults and extra helpers that make it easier to accomplish common tasks. Tortoise-ORM is one of the best tool to interact with the database asynchronously. It's clean and Django type implementation provides you a better view and understanding of the database ORM system. Also you can use the Pydantic data module to write the error-less code. The main aim of Tortoise-ORM is to provide the same service and api like the Django-ORM . Installation \u00b6 Install or update from PYPI \u00b6 pip install -U Flask-Tortoise Install from source code \u00b6 $ git clone https://github.com/marktennyson/Flask-Tortoise $ cd Flask-Tortoise && pip install . Features \u00b6 Fully asynchronous support. Clean, familiar python interface. Pluggable Database backends. Reach query system like Django. Composable, Django-inspired Models Proper implementation of different types of relation fields. Extra QuerySet added and pagination support. please check the official documentation of Tortoise-ORM for more details at: https://tortoise-orm.readthedocs.io/en/latest/ Available configs \u00b6 TORTOISE_ORM_DATABASE_URI: ad the database url here. Mandatory field Type: str TORTOISE_ORM_MODELS: add the name of the all model file. Default value: app.import_name Type: str TORTOISE_ORM_MODULES: add the tortoise orm module dict here if you are about to initialize it by modules. Default value: {} Type: dict TORTOISE_ORM_CONFIG: Initialize the tortoise Orm with the config dictionary. Default value: {} Type: dict TORTOISE_ORM_CONFIG_FILE: Initialize the tortoise orm from a config file. Default value: None Type: optional-str TORTOISE_ORM_GENERATE_SCHEMAS: generate the schemas at the time of tortoise orm initialization. Default value: False Type: bool A Basic demo for better understanding \u00b6 from flask import Flask , jsonify from flask_tortoise import Tortoise , Model , fields from random import choice STATUSES = [ \"New\" , \"Old\" , \"Gone\" ] app : \"Flask\" = Flask ( __name__ ) app . config [ 'TORTOISE_ORM_DATABASE_URI' ] = 'sqlite://db.sqlite3' db : \"Tortoise\" = Tortoise ( app ) class Users ( Model ): id = fields . IntField ( pk = True ) status = fields . CharField ( 20 ) def __str__ ( self ): return f \"User { self . id } : { self . status } \" class Workers ( Model ): id = fields . IntField ( pk = True ) status = fields . CharField ( 20 ) def __str__ ( self ): return f \"Worker { self . id } : { self . status } \" @app . get ( \"/\" ) async def list_all (): users = await Users . all () workers = await Workers . all () return jsonify ( { \"users\" : [ str ( user ) for user in users ], \"workers\" : [ str ( worker ) for worker in workers ]} ) @app . get ( \"/user\" ) async def add_user (): user = await Users . create ( status = choice ( STATUSES )) # nosec return str ( user ) @app . get ( \"/worker\" ) async def add_worker (): worker = await Workers . create ( status = choice ( STATUSES )) # nosec return str ( worker ) @app . get ( \"/get-worker\" ) async def get_worker (): worker : \"Workers\" = await Workers . get ( id = 1 ) return str ( worker . status ) if __name__ == '__main__' : app . run ( debug = True , port = 8080 ) If you save your models into a separate file than you have mention the file name on app config: let's assume you have stores all of your models at models.py file. models.py file: from flask_tortoise import Tortoise , Model , fields db : \"Tortoise\" = Tortoise () class Users ( Model ): id = fields . IntField ( pk = True ) status = fields . CharField ( 20 ) def __str__ ( self ): return f \"User { self . id } : { self . status } \" class Workers ( Model ): id = fields . IntField ( pk = True ) status = fields . CharField ( 20 ) def __str__ ( self ): return f \"Worker { self . id } : { self . status } \" app.py file: from flask import Flask , jsonify from models import * from random import choice STATUSES = [ \"New\" , \"Old\" , \"Gone\" ] app : \"Flask\" = Flask ( __name__ ) app . config [ 'TORTOISE_ORM_DATABASE_URI' ] = 'sqlite://db.sqlite3' app . config [ 'TORTOISE_ORM_MODELS' ] = \"models\" # if you have more than one models file then : [\"models_1\", \"models_2\", \"models_3\"] db . init_app ( app ) @app . get ( \"/\" ) async def list_all (): users = await Users . all () workers = await Workers . all () return jsonify ( { \"users\" : [ str ( user ) for user in users ], \"workers\" : [ str ( worker ) for worker in workers ]} ) @app . get ( \"/user\" ) async def add_user (): user = await Users . create ( status = choice ( STATUSES )) # nosec return str ( user ) @app . get ( \"/worker\" ) async def add_worker (): worker = await Workers . create ( status = choice ( STATUSES )) # nosec return str ( worker ) @app . get ( \"/get-worker\" ) async def get_worker (): worker : \"Workers\" = await Workers . get ( id = 1 ) return str ( worker . status ) if __name__ == '__main__' : app . run ( debug = True , port = 8080 )","title":"Flask-Tortoise"},{"location":"#flask-tortoise-asynchronous-database-support-for-flask","text":"Documentation: https://navycut.github.io Github Repo: https://github.com/navycut/navycut","title":"Flask-Tortoise - Asynchronous database support for Flask"},{"location":"#introduction","text":"Flask-Tortoise is an extension for Flask that adds support for asynchronous Tortoise-ORM to your application with in-built migration system. It aims to simplify using Tortoise-ORM with Flask by providing useful defaults and extra helpers that make it easier to accomplish common tasks. Tortoise-ORM is one of the best tool to interact with the database asynchronously. It's clean and Django type implementation provides you a better view and understanding of the database ORM system. Also you can use the Pydantic data module to write the error-less code. The main aim of Tortoise-ORM is to provide the same service and api like the Django-ORM .","title":"Introduction"},{"location":"#installation","text":"","title":"Installation"},{"location":"#install-or-update-from-pypi","text":"pip install -U Flask-Tortoise","title":"Install or update from PYPI"},{"location":"#install-from-source-code","text":"$ git clone https://github.com/marktennyson/Flask-Tortoise $ cd Flask-Tortoise && pip install .","title":"Install from source code"},{"location":"#features","text":"Fully asynchronous support. Clean, familiar python interface. Pluggable Database backends. Reach query system like Django. Composable, Django-inspired Models Proper implementation of different types of relation fields. Extra QuerySet added and pagination support. please check the official documentation of Tortoise-ORM for more details at: https://tortoise-orm.readthedocs.io/en/latest/","title":"Features"},{"location":"#available-configs","text":"TORTOISE_ORM_DATABASE_URI: ad the database url here. Mandatory field Type: str TORTOISE_ORM_MODELS: add the name of the all model file. Default value: app.import_name Type: str TORTOISE_ORM_MODULES: add the tortoise orm module dict here if you are about to initialize it by modules. Default value: {} Type: dict TORTOISE_ORM_CONFIG: Initialize the tortoise Orm with the config dictionary. Default value: {} Type: dict TORTOISE_ORM_CONFIG_FILE: Initialize the tortoise orm from a config file. Default value: None Type: optional-str TORTOISE_ORM_GENERATE_SCHEMAS: generate the schemas at the time of tortoise orm initialization. Default value: False Type: bool","title":"Available configs"},{"location":"#a-basic-demo-for-better-understanding","text":"from flask import Flask , jsonify from flask_tortoise import Tortoise , Model , fields from random import choice STATUSES = [ \"New\" , \"Old\" , \"Gone\" ] app : \"Flask\" = Flask ( __name__ ) app . config [ 'TORTOISE_ORM_DATABASE_URI' ] = 'sqlite://db.sqlite3' db : \"Tortoise\" = Tortoise ( app ) class Users ( Model ): id = fields . IntField ( pk = True ) status = fields . CharField ( 20 ) def __str__ ( self ): return f \"User { self . id } : { self . status } \" class Workers ( Model ): id = fields . IntField ( pk = True ) status = fields . CharField ( 20 ) def __str__ ( self ): return f \"Worker { self . id } : { self . status } \" @app . get ( \"/\" ) async def list_all (): users = await Users . all () workers = await Workers . all () return jsonify ( { \"users\" : [ str ( user ) for user in users ], \"workers\" : [ str ( worker ) for worker in workers ]} ) @app . get ( \"/user\" ) async def add_user (): user = await Users . create ( status = choice ( STATUSES )) # nosec return str ( user ) @app . get ( \"/worker\" ) async def add_worker (): worker = await Workers . create ( status = choice ( STATUSES )) # nosec return str ( worker ) @app . get ( \"/get-worker\" ) async def get_worker (): worker : \"Workers\" = await Workers . get ( id = 1 ) return str ( worker . status ) if __name__ == '__main__' : app . run ( debug = True , port = 8080 ) If you save your models into a separate file than you have mention the file name on app config: let's assume you have stores all of your models at models.py file. models.py file: from flask_tortoise import Tortoise , Model , fields db : \"Tortoise\" = Tortoise () class Users ( Model ): id = fields . IntField ( pk = True ) status = fields . CharField ( 20 ) def __str__ ( self ): return f \"User { self . id } : { self . status } \" class Workers ( Model ): id = fields . IntField ( pk = True ) status = fields . CharField ( 20 ) def __str__ ( self ): return f \"Worker { self . id } : { self . status } \" app.py file: from flask import Flask , jsonify from models import * from random import choice STATUSES = [ \"New\" , \"Old\" , \"Gone\" ] app : \"Flask\" = Flask ( __name__ ) app . config [ 'TORTOISE_ORM_DATABASE_URI' ] = 'sqlite://db.sqlite3' app . config [ 'TORTOISE_ORM_MODELS' ] = \"models\" # if you have more than one models file then : [\"models_1\", \"models_2\", \"models_3\"] db . init_app ( app ) @app . get ( \"/\" ) async def list_all (): users = await Users . all () workers = await Workers . all () return jsonify ( { \"users\" : [ str ( user ) for user in users ], \"workers\" : [ str ( worker ) for worker in workers ]} ) @app . get ( \"/user\" ) async def add_user (): user = await Users . create ( status = choice ( STATUSES )) # nosec return str ( user ) @app . get ( \"/worker\" ) async def add_worker (): worker = await Workers . create ( status = choice ( STATUSES )) # nosec return str ( worker ) @app . get ( \"/get-worker\" ) async def get_worker (): worker : \"Workers\" = await Workers . get ( id = 1 ) return str ( worker . status ) if __name__ == '__main__' : app . run ( debug = True , port = 8080 )","title":"A Basic demo for better understanding"},{"location":"cli/","text":"Command Line Interface to Migrate the Database \u00b6 Introduction \u00b6 This document describes how to use the command line to make migrations while using Flask-Tortoise . Internally it's using Aerich module to provide the migration support. Special thanks to the author of Aerich module. Quick Start \u00b6 Flask-Tortoise module is connected to the flask.Flask.cli click-group. So you can use the command line as same as the other flask extensions. $ flask tortoise --help Usage: flask tortoise [ OPTIONS ] COMMAND [ ARGS ] ... the default command line interface to manage the version of the tortoise orm. Options: -h, --help Show this message and exit. Commands: downgrade Downgrade to specified version. heads Show current available heads in migrate location. history List all migrate items. init Initialize the orm. init-db Generate schema and generate app migrate location. inspectdb Introspects the database tables to standard output as... migrate Generate migrate changes file. upgrade Upgrade to specified version. Usage \u00b6 Initialization \u00b6 $ flask tortoise init --help Usage: flask tortoise init [ OPTIONS ] Init config file and generate root migrate location. Options: -t, --tortoise-orm TEXT Tortoise-ORM config module dict variable, like settings.TORTOISE_ORM. [ required ] --location TEXT Migrate store location. [ default: ./migrations ] -h, --help Show this message and exit. Init DB \u00b6 $ flask tortoise init-db Success create app migrate location ./migrations/models Success generate schema for app \"models\" Note: If your models not present at the __main__ file then you must need to pass the models file name at the app config: TORTOISE_DATABASE_MODLES . Update models and make migrate \u00b6 $ flask tortoise migrate --name drop_column Success migrate 1_202029051520102929_drop_column.sql Format of migrate filename is {version_num} {datetime} .sql. And if it guess you are renaming a column, it will ask Rename {old_column} to {new_column} [True], you can choice True to rename column without column drop, or choice False to drop column then create. If you use MySQL, only MySQL8.0+ support rename..to syntax. Upgrade to latest version \u00b6 $ flask tortoise upgrade Success upgrade 1_202029051520102929_drop_column.sql Now your db is migrated to latest. Downgrade to specified version \u00b6 $ flask tortoise downgrade --help Usage: flask tortoise downgrade [ OPTIONS ] Downgrade to specified version. Options: -v, --version INTEGER Specified version, default to last. [ default: -1 ] -d, --delete Delete version files at the same time. [ default: False ] -h, --help Show this message and exit. $ flask tortoise downgrade Success downgrade 1_202029051520102929_drop_column.sql Now your db rollback to specified version. Show history \u00b6 $ flask tortoise history 1_202029051520102929_drop_column.sql Show heads to be migrated \u00b6 $ aerich heads 1_202029051520102929_drop_column.sql","title":"Command Line"},{"location":"cli/#command-line-interface-to-migrate-the-database","text":"","title":"Command Line Interface to Migrate the Database"},{"location":"cli/#introduction","text":"This document describes how to use the command line to make migrations while using Flask-Tortoise . Internally it's using Aerich module to provide the migration support. Special thanks to the author of Aerich module.","title":"Introduction"},{"location":"cli/#quick-start","text":"Flask-Tortoise module is connected to the flask.Flask.cli click-group. So you can use the command line as same as the other flask extensions. $ flask tortoise --help Usage: flask tortoise [ OPTIONS ] COMMAND [ ARGS ] ... the default command line interface to manage the version of the tortoise orm. Options: -h, --help Show this message and exit. Commands: downgrade Downgrade to specified version. heads Show current available heads in migrate location. history List all migrate items. init Initialize the orm. init-db Generate schema and generate app migrate location. inspectdb Introspects the database tables to standard output as... migrate Generate migrate changes file. upgrade Upgrade to specified version.","title":"Quick Start"},{"location":"cli/#usage","text":"","title":"Usage"},{"location":"cli/#initialization","text":"$ flask tortoise init --help Usage: flask tortoise init [ OPTIONS ] Init config file and generate root migrate location. Options: -t, --tortoise-orm TEXT Tortoise-ORM config module dict variable, like settings.TORTOISE_ORM. [ required ] --location TEXT Migrate store location. [ default: ./migrations ] -h, --help Show this message and exit.","title":"Initialization"},{"location":"cli/#init-db","text":"$ flask tortoise init-db Success create app migrate location ./migrations/models Success generate schema for app \"models\" Note: If your models not present at the __main__ file then you must need to pass the models file name at the app config: TORTOISE_DATABASE_MODLES .","title":"Init DB"},{"location":"cli/#update-models-and-make-migrate","text":"$ flask tortoise migrate --name drop_column Success migrate 1_202029051520102929_drop_column.sql Format of migrate filename is {version_num} {datetime} .sql. And if it guess you are renaming a column, it will ask Rename {old_column} to {new_column} [True], you can choice True to rename column without column drop, or choice False to drop column then create. If you use MySQL, only MySQL8.0+ support rename..to syntax.","title":"Update models and make migrate"},{"location":"cli/#upgrade-to-latest-version","text":"$ flask tortoise upgrade Success upgrade 1_202029051520102929_drop_column.sql Now your db is migrated to latest.","title":"Upgrade to latest version"},{"location":"cli/#downgrade-to-specified-version","text":"$ flask tortoise downgrade --help Usage: flask tortoise downgrade [ OPTIONS ] Downgrade to specified version. Options: -v, --version INTEGER Specified version, default to last. [ default: -1 ] -d, --delete Delete version files at the same time. [ default: False ] -h, --help Show this message and exit. $ flask tortoise downgrade Success downgrade 1_202029051520102929_drop_column.sql Now your db rollback to specified version.","title":"Downgrade to specified version"},{"location":"cli/#show-history","text":"$ flask tortoise history 1_202029051520102929_drop_column.sql","title":"Show history"},{"location":"cli/#show-heads-to-be-migrated","text":"$ aerich heads 1_202029051520102929_drop_column.sql","title":"Show heads to be migrated"},{"location":"examples/","text":"Simple Examples \u00b6 Basic \u00b6 \"\"\" This example demonstrates most basic operations with single model \"\"\" from flask import Flask from flask_tortoise import Tortoise app = Flask ( __name__ ) db = Tortoise ( app ) class Event ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () datetime = db . DatetimeField ( null = True ) class Meta : table = \"event\" def __str__ ( self ): return self . name @app . get ( \"/event\" ) async def event (): event = await Event . create ( name = \"Test\" ) await Event . filter ( id = event . id ) . update ( name = \"Updated name\" ) print ( await Event . filter ( name = \"Updated name\" ) . first ()) # >>> Updated name await Event ( name = \"Test 2\" ) . save () print ( await Event . all () . values_list ( \"id\" , flat = True )) # >>> [1, 2] print ( await Event . all () . values ( \"id\" , \"name\" )) # >>> [{'id': 1, 'name': 'Updated name'}, {'id': 2, 'name': 'Test 2'}] return \"null\" if __name__ == \"__main__\" : app . run () Comments \u00b6 \"\"\" This example demonstrates most basic operations with single model and a Table definition generation with comment support \"\"\" class Event ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField ( description = \"Name of the event that corresponds to an action\" ) datetime = db . DatetimeField ( null = True , description = \"Datetime of when the event was generated\" ) class Meta : table = \"event\" table_description = \"This table contains a list of all the example events\" def __str__ ( self ): return self . name @app . route ( \"/events\" ) async def events (): event = await Event . create ( name = \"Test\" ) await Event . filter ( id = event . id ) . update ( name = \"Updated name\" ) print ( await Event . filter ( name = \"Updated name\" ) . first ()) await Event ( name = \"Test 2\" ) . save () print ( await Event . all () . values_list ( \"id\" , flat = True )) print ( await Event . all () . values ( \"id\" , \"name\" )) return 'null' if __name__ == \"__main__\" : app . run () Prefetching \u00b6 from tortoise.query_utils import Prefetch class Tournament ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () events : db . ReverseRelation [ \"Event\" ] def __str__ ( self ): return self . name class Event ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () tournament : db . ForeignKeyRelation [ Tournament ] = db . ForeignKeyField ( \"db.Tournament\" , related_name = \"events\" ) participants : db . ManyToManyRelation [ \"Team\" ] = db . ManyToManyField ( \"db.Team\" , related_name = \"events\" , through = \"event_team\" ) def __str__ ( self ): return self . name class Team ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () events : db . ManyToManyRelation [ Event ] def __str__ ( self ): return self . name @app . route ( \"/events\" ) async def events (): tournament = await Tournament . create ( name = \"tournament\" ) await Event . create ( name = \"First\" , tournament = tournament ) await Event . create ( name = \"Second\" , tournament = tournament ) tournament_with_filtered = ( await Tournament . all () . prefetch_related ( Prefetch ( \"events\" , queryset = Event . filter ( name = \"First\" ))) . first () ) print ( tournament_with_filtered ) print ( await Tournament . first () . prefetch_related ( \"events\" )) tournament_with_filtered_to_attr = ( await Tournament . all () . prefetch_related ( Prefetch ( \"events\" , queryset = Event . filter ( name = \"First\" ), to_attr = \"to_attr_events_first\" ), Prefetch ( \"events\" , queryset = Event . filter ( name = \"Second\" ), to_attr = \"to_attr_events_second\" ), ) . first () ) print ( tournament_with_filtered_to_attr . to_attr_events_first ) print ( tournament_with_filtered_to_attr . to_attr_events_second ) return 'null' if __name__ == \"__main__\" : app . run () Transactions \u00b6 \"\"\" This example demonstrates how you can use transactions with tortoise \"\"\" from tortoise.exceptions import OperationalError from tortoise.transactions import atomic , in_transaction class Event ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () class Meta : table = \"event\" def __str__ ( self ): return self . name @app . route ( \"/run\" ) async def run (): try : async with in_transaction () as connection : event = Event ( name = \"Test\" ) await event . save ( using_db = connection ) await Event . filter ( id = event . id ) . using_db ( connection ) . update ( name = \"Updated name\" ) saved_event = await Event . filter ( name = \"Updated name\" ) . using_db ( connection ) . first () await connection . execute_query ( \"SELECT * FROM non_existent_table\" ) except OperationalError : pass saved_event = await Event . filter ( name = \"Updated name\" ) . first () print ( saved_event ) @atomic () async def bound_to_fall (): event = await Event . create ( name = \"Test\" ) await Event . filter ( id = event . id ) . update ( name = \"Updated name\" ) saved_event = await Event . filter ( name = \"Updated name\" ) . first () print ( saved_event . name ) raise OperationalError () try : await bound_to_fall () except OperationalError : pass saved_event = await Event . filter ( name = \"Updated name\" ) . first () print ( saved_event ) return 'null' if __name__ == \"__main__\" : app . run () Functions \u00b6 from tortoise.functions import Coalesce , Count , Length , Lower , Min , Sum , Trim , Upper from tortoise.query_utils import Q class Tournament ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () desc = db . TextField ( null = True ) events : db . ReverseRelation [ \"Event\" ] def __str__ ( self ): return self . name class Event ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () tournament : db . ForeignKeyRelation [ Tournament ] = db . ForeignKeyField ( \"models.Tournament\" , related_name = \"events\" ) participants : db . ManyToManyRelation [ \"Team\" ] = db . ManyToManyField ( \"models.Team\" , related_name = \"events\" , through = \"event_team\" ) def __str__ ( self ): return self . name class Team ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () events : db . ManyToManyRelation [ Event ] def __str__ ( self ): return self . name @app . route ( \"/runs\" ) async def run (): tournament = await Tournament . create ( name = \"New Tournament\" , desc = \"great\" ) await tournament . save () await Tournament . create ( name = \"Second tournament\" ) await Tournament . create ( name = \" final tournament \" ) await Event ( name = \"Without participants\" , tournament_id = tournament . id ) . save () event = Event ( name = \"Test\" , tournament_id = tournament . id ) await event . save () participants = [] for i in range ( 2 ): team = Team ( name = f \"Team { ( i + 1 ) } \" ) await team . save () participants . append ( team ) await event . participants . add ( participants [ 0 ], participants [ 1 ]) await event . participants . add ( participants [ 0 ], participants [ 1 ]) print ( await Tournament . all () . annotate ( events_count = Count ( \"events\" )) . filter ( events_count__gte = 1 )) print ( await Tournament . all () . annotate ( events_count_with_filter = Count ( \"events\" , _filter = Q ( name = \"New Tournament\" ))) . filter ( events_count_with_filter__gte = 1 ) ) print ( await Event . filter ( id = event . id ) . first () . annotate ( lowest_team_id = Min ( \"participants__id\" ))) print ( await Tournament . all () . annotate ( events_count = Count ( \"events\" )) . order_by ( \"events_count\" )) print ( await Event . all () . annotate ( tournament_test_id = Sum ( \"tournament__id\" )) . first ()) print ( await Tournament . annotate ( clean_desciption = Coalesce ( \"desc\" , \"\" )) . filter ( clean_desciption = \"\" ) ) print ( await Tournament . annotate ( trimmed_name = Trim ( \"name\" )) . filter ( trimmed_name = \"final tournament\" ) ) print ( await Tournament . annotate ( name_len = Length ( \"name\" )) . filter ( name_len__gt = len ( \"New Tournament\" ) ) ) print ( await Tournament . annotate ( name_lo = Lower ( \"name\" )) . filter ( name_lo = \"new tournament\" )) print ( await Tournament . annotate ( name_lo = Upper ( \"name\" )) . filter ( name_lo = \"NEW TOURNAMENT\" )) return 'null' if __name__ == \"__main__\" : app . run () Group By \u00b6 from tortoise.functions import Avg , Count , Sum class Author ( db . Model ): name = db . CharField ( max_length = 255 ) class Book ( db . Model ): name = db . CharField ( max_length = 255 ) author = db . ForeignKeyField ( \"models.Author\" , related_name = \"books\" ) rating = db . FloatField () @app . route ( \"/runs\" ) async def run (): a1 = await Author . create ( name = \"author1\" ) a2 = await Author . create ( name = \"author2\" ) for i in range ( 10 ): await Book . create ( name = f \"book { i } \" , author = a1 , rating = i ) for i in range ( 5 ): await Book . create ( name = f \"book { i } \" , author = a2 , rating = i ) ret = await Book . annotate ( count = Count ( \"id\" )) . group_by ( \"author_id\" ) . values ( \"author_id\" , \"count\" ) print ( ret ) # >>> [{'author_id': 1, 'count': 10}, {'author_id': 2, 'count': 5}] ret = ( await Book . annotate ( count = Count ( \"id\" )) . filter ( count__gt = 6 ) . group_by ( \"author_id\" ) . values ( \"author_id\" , \"count\" ) ) print ( ret ) # >>> [{'author_id': 1, 'count': 10}] ret = await Book . annotate ( sum = Sum ( \"rating\" )) . group_by ( \"author_id\" ) . values ( \"author_id\" , \"sum\" ) print ( ret ) # >>> [{'author_id': 1, 'sum': 45.0}, {'author_id': 2, 'sum': 10.0}] ret = ( await Book . annotate ( sum = Sum ( \"rating\" )) . filter ( sum__gt = 11 ) . group_by ( \"author_id\" ) . values ( \"author_id\" , \"sum\" ) ) print ( ret ) # >>> [{'author_id': 1, 'sum': 45.0}] ret = await Book . annotate ( avg = Avg ( \"rating\" )) . group_by ( \"author_id\" ) . values ( \"author_id\" , \"avg\" ) print ( ret ) # >>> [{'author_id': 1, 'avg': 4.5}, {'author_id': 2, 'avg': 2.0}] ret = ( await Book . annotate ( avg = Avg ( \"rating\" )) . filter ( avg__gt = 3 ) . group_by ( \"author_id\" ) . values ( \"author_id\" , \"avg\" ) ) print ( ret ) # >>> [{'author_id': 1, 'avg': 4.5}] # and use .values_list() ret = ( await Book . annotate ( count = Count ( \"id\" )) . group_by ( \"author_id\" ) . values_list ( \"author_id\" , \"count\" ) ) print ( ret ) # >>> [(1, 10), (2, 5)] # group by with join ret = ( await Book . annotate ( count = Count ( \"id\" )) . group_by ( \"author__name\" ) . values ( \"author__name\" , \"count\" ) ) print ( ret ) # >>> [{\"author__name\": \"author1\", \"count\": 10}, {\"author__name\": \"author2\", \"count\": 5}] return 'null' if __name__ == \"__main__\" : app . run () Filtering \u00b6 \"\"\" This example shows some more complex querying Key points are filtering by related names and using Q objects \"\"\" from tortoise.query_utils import Q class Tournament ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () events : db . ReverseRelation [ \"Event\" ] def __str__ ( self ): return self . name class Event ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () tournament : db . ForeignKeyRelation [ Tournament ] = db . ForeignKeyField ( \"models.Tournament\" , related_name = \"events\" ) participants : db . ManyToManyRelation [ \"Team\" ] = db . ManyToManyField ( \"models.Team\" , related_name = \"events\" , through = \"event_team\" ) def __str__ ( self ): return self . name class Team ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () events : db . ManyToManyRelation [ Event ] def __str__ ( self ): return self . name @app . route ( \"/aniket\" ) async def run (): tournament = Tournament ( name = \"Tournament\" ) await tournament . save () second_tournament = Tournament ( name = \"Tournament 2\" ) await second_tournament . save () event_first = Event ( name = \"1\" , tournament = tournament ) await event_first . save () event_second = await Event . create ( name = \"2\" , tournament = second_tournament ) await Event . create ( name = \"3\" , tournament = tournament ) await Event . create ( name = \"4\" , tournament = second_tournament ) await Event . filter ( tournament = tournament ) team_first = Team ( name = \"First\" ) await team_first . save () team_second = Team ( name = \"Second\" ) await team_second . save () await team_first . events . add ( event_first ) await event_second . participants . add ( team_second ) print ( await Event . filter ( Q ( id__in = [ event_first . id , event_second . id ]) | Q ( name = \"3\" )) . filter ( participants__not = team_second . id ) . order_by ( \"tournament__id\" ) . distinct () ) print ( await Team . filter ( events__tournament_id = tournament . id ) . order_by ( \"-events__name\" )) print ( await Tournament . filter ( events__name__in = [ \"1\" , \"3\" ]) . order_by ( \"-events__participants__name\" ) . distinct () ) print ( await Team . filter ( name__icontains = \"CON\" )) print ( await Tournament . filter ( events__participants__name__startswith = \"Fir\" )) print ( await Tournament . filter ( id__icontains = 1 ) . count ()) return 'null' if __name__ == \"__main__\" : app . run () Relations \u00b6 \"\"\" This example shows how relations between models work. Key points in this example are use of ForeignKeyField and ManyToManyField to declare relations and use of .prefetch_related() and .fetch_related() to get this related objects \"\"\" from tortoise.exceptions import NoValuesFetched class Tournament ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () events : db . ReverseRelation [ \"Event\" ] def __str__ ( self ): return self . name class Event ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () tournament : db . ForeignKeyRelation [ Tournament ] = db . ForeignKeyField ( \"models.Tournament\" , related_name = \"events\" ) participants : db . ManyToManyRelation [ \"Team\" ] = db . ManyToManyField ( \"models.Team\" , related_name = \"events\" , through = \"event_team\" ) def __str__ ( self ): return self . name class Address ( db . Model ): city = db . CharField ( max_length = 64 ) street = db . CharField ( max_length = 128 ) event : db . OneToOneRelation [ Event ] = db . OneToOneField ( \"models.Event\" , on_delete = db . CASCADE , related_name = \"address\" , pk = True ) def __str__ ( self ): return f \"Address( { self . city } , { self . street } )\" class Team ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () events : db . ManyToManyRelation [ Event ] def __str__ ( self ): return self . name @app . route ( \"/verloop\" ) async def run (): tournament = Tournament ( name = \"New Tournament\" ) await tournament . save () await Event ( name = \"Without participants\" , tournament_id = tournament . id ) . save () event = Event ( name = \"Test\" , tournament_id = tournament . id ) await event . save () await Address . create ( city = \"Santa Monica\" , street = \"Ocean\" , event = event ) participants = [] for i in range ( 2 ): team = Team ( name = f \"Team { ( i + 1 ) } \" ) await team . save () participants . append ( team ) await event . participants . add ( participants [ 0 ], participants [ 1 ]) await event . participants . add ( participants [ 0 ], participants [ 1 ]) try : for team in event . participants : print ( team . id ) except NoValuesFetched : pass async for team in event . participants : print ( team . id ) for team in event . participants : print ( team . id ) print ( await Event . filter ( participants = participants [ 0 ] . id ) . prefetch_related ( \"participants\" , \"tournament\" ) ) print ( await participants [ 0 ] . fetch_related ( \"events\" )) print ( await Team . fetch_for_list ( participants , \"events\" )) print ( await Team . filter ( events__tournament__id = tournament . id )) print ( await Event . filter ( tournament = tournament )) print ( await Tournament . filter ( events__name__in = [ \"Test\" , \"Prod\" ]) . order_by ( \"-events__participants__name\" ) . distinct () ) print ( await Event . filter ( id = event . id ) . values ( \"id\" , \"name\" , tournament = \"tournament__name\" )) print ( await Event . filter ( id = event . id ) . values_list ( \"id\" , \"participants__name\" )) print ( await Address . filter ( event = event ) . first ()) event_reload1 = await Event . filter ( id = event . id ) . first () print ( await event_reload1 . address ) event_reload2 = await Event . filter ( id = event . id ) . prefetch_related ( \"address\" ) . first () print ( event_reload2 . address ) return 'null' if __name__ == \"__main__\" : app . run () Relations with Unique field \u00b6 \"\"\" This example shows how relations between models especially unique field work. Key points in this example are use of ForeignKeyField and OneToOneField has to_field. For other basic parts, it is the same as relation exmaple. \"\"\" from tortoise.query_utils import Prefetch class School ( db . Model ): uuid = db . UUIDField ( pk = True ) name = db . TextField () id = db . IntField ( unique = True ) students : db . ReverseRelation [ \"Student\" ] principal : db . ReverseRelation [ \"Principal\" ] class Student ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () school : db . ForeignKeyRelation [ School ] = db . ForeignKeyField ( \"models.School\" , related_name = \"students\" , to_field = \"id\" ) class Principal ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () school : db . OneToOneRelation [ School ] = db . OneToOneField ( \"models.School\" , on_delete = db . CASCADE , related_name = \"principal\" , to_field = \"id\" ) @app . route ( \"/forloop\" ) async def run (): school1 = await School . create ( id = 1024 , name = \"School1\" ) student1 = await Student . create ( name = \"Sang-Heon Jeon1\" , school_id = school1 . id ) student_schools = await Student . filter ( name = \"Sang-Heon Jeon1\" ) . values ( \"name\" , \"school__name\" ) print ( student_schools [ 0 ]) await Student . create ( name = \"Sang-Heon Jeon2\" , school = school1 ) school_with_filtered = ( await School . all () . prefetch_related ( Prefetch ( \"students\" , queryset = Student . filter ( name = \"Sang-Heon Jeon1\" ))) . first () ) school_without_filtered = await School . first () . prefetch_related ( \"students\" ) print ( len ( school_with_filtered . students )) print ( len ( school_without_filtered . students )) school2 = await School . create ( id = 2048 , name = \"School2\" ) await Student . all () . update ( school = school2 ) student = await Student . first () print ( student . school_id ) await Student . filter ( id = student1 . id ) . update ( school = school1 ) schools = await School . all () . order_by ( \"students__name\" ) print ([ school . name for school in schools ]) fetched_principal = await Principal . create ( name = \"Sang-Heon Jeon3\" , school = school1 ) print ( fetched_principal . name ) fetched_school = await School . filter ( name = \"School1\" ) . prefetch_related ( \"principal\" ) . first () print ( fetched_school . name ) return 'null' if __name__ == \"__main__\" : app . run () Recursive relations \u00b6 \"\"\" This example shows how self-referential (recursive) relations work. Key points in this example are: * Use of ForeignKeyField that refers to self * To pass in the (optional) parent node at creation * To use async iterator to fetch children * To use .fetch_related(\u2026) to emulate sync behaviour * That insert-order gets preserved for ForeignFields, but not ManyToManyFields \"\"\" class Employee ( db . Model ): name = db . CharField ( max_length = 50 ) manager : db . ForeignKeyNullableRelation [ \"Employee\" ] = db . ForeignKeyField ( \"models.Employee\" , related_name = \"team_members\" , null = True ) team_members : db . ReverseRelation [ \"Employee\" ] talks_to : db . ManyToManyRelation [ \"Employee\" ] = db . ManyToManyField ( \"models.Employee\" , related_name = \"gets_talked_to\" ) gets_talked_to : db . ManyToManyRelation [ \"Employee\" ] def __str__ ( self ): return self . name async def full_hierarchy__async_for ( self , level = 0 ): \"\"\" Demonstrates ``async for` to fetch relations An async iterator will fetch the relationship on-demand. \"\"\" text = [ \" {}{} (to: {} ) (from: {} )\" . format ( level * \" \" , self , \", \" . join ([ str ( val ) async for val in self . talks_to ]), \", \" . join ([ str ( val ) async for val in self . gets_talked_to ]), ) ] async for member in self . team_members : text . append ( await member . full_hierarchy__async_for ( level + 1 )) return \" \\n \" . join ( text ) async def full_hierarchy__fetch_related ( self , level = 0 ): \"\"\" Demonstrates ``await .fetch_related`` to fetch relations On prefetching the data, the relationship files will contain a regular list. This is how one would get relations working on sync serialization/templating frameworks. \"\"\" await self . fetch_related ( \"team_members\" , \"talks_to\" , \"gets_talked_to\" ) text = [ \" {}{} (to: {} ) (from: {} )\" . format ( level * \" \" , self , \", \" . join ([ str ( val ) for val in self . talks_to ]), \", \" . join ([ str ( val ) for val in self . gets_talked_to ]), ) ] for member in self . team_members : text . append ( await member . full_hierarchy__fetch_related ( level + 1 )) return \" \\n \" . join ( text ) @app . route ( \"/relationer\" ) async def run (): root = await Employee . create ( name = \"Root\" ) loose = await Employee . create ( name = \"Loose\" ) _1 = await Employee . create ( name = \"1. First H1\" , manager = root ) _2 = await Employee . create ( name = \"2. Second H1\" , manager = root ) _1_1 = await Employee . create ( name = \"1.1. First H2\" , manager = _1 ) _1_1_1 = await Employee . create ( name = \"1.1.1. First H3\" , manager = _1_1 ) _2_1 = await Employee . create ( name = \"2.1. Second H2\" , manager = _2 ) _2_2 = await Employee . create ( name = \"2.2. Third H2\" , manager = _2 ) await _1 . talks_to . add ( _2 , _1_1_1 , loose ) await _2_1 . gets_talked_to . add ( _2_2 , _1_1 , loose ) # Evaluated off creation objects print ( await loose . full_hierarchy__fetch_related ()) print ( await root . full_hierarchy__async_for ()) print ( await root . full_hierarchy__fetch_related ()) # Evaluated off new objects \u2192 Result is identical root2 = await Employee . get ( name = \"Root\" ) loose2 = await Employee . get ( name = \"Loose\" ) print ( await loose2 . full_hierarchy__fetch_related ()) print ( await root2 . full_hierarchy__async_for ()) print ( await root2 . full_hierarchy__fetch_related ()) return 'null' if __name__ == \"__main__\" : app . run ()","title":"Examples"},{"location":"examples/#simple-examples","text":"","title":"Simple Examples"},{"location":"examples/#basic","text":"\"\"\" This example demonstrates most basic operations with single model \"\"\" from flask import Flask from flask_tortoise import Tortoise app = Flask ( __name__ ) db = Tortoise ( app ) class Event ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () datetime = db . DatetimeField ( null = True ) class Meta : table = \"event\" def __str__ ( self ): return self . name @app . get ( \"/event\" ) async def event (): event = await Event . create ( name = \"Test\" ) await Event . filter ( id = event . id ) . update ( name = \"Updated name\" ) print ( await Event . filter ( name = \"Updated name\" ) . first ()) # >>> Updated name await Event ( name = \"Test 2\" ) . save () print ( await Event . all () . values_list ( \"id\" , flat = True )) # >>> [1, 2] print ( await Event . all () . values ( \"id\" , \"name\" )) # >>> [{'id': 1, 'name': 'Updated name'}, {'id': 2, 'name': 'Test 2'}] return \"null\" if __name__ == \"__main__\" : app . run ()","title":"Basic"},{"location":"examples/#comments","text":"\"\"\" This example demonstrates most basic operations with single model and a Table definition generation with comment support \"\"\" class Event ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField ( description = \"Name of the event that corresponds to an action\" ) datetime = db . DatetimeField ( null = True , description = \"Datetime of when the event was generated\" ) class Meta : table = \"event\" table_description = \"This table contains a list of all the example events\" def __str__ ( self ): return self . name @app . route ( \"/events\" ) async def events (): event = await Event . create ( name = \"Test\" ) await Event . filter ( id = event . id ) . update ( name = \"Updated name\" ) print ( await Event . filter ( name = \"Updated name\" ) . first ()) await Event ( name = \"Test 2\" ) . save () print ( await Event . all () . values_list ( \"id\" , flat = True )) print ( await Event . all () . values ( \"id\" , \"name\" )) return 'null' if __name__ == \"__main__\" : app . run ()","title":"Comments"},{"location":"examples/#prefetching","text":"from tortoise.query_utils import Prefetch class Tournament ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () events : db . ReverseRelation [ \"Event\" ] def __str__ ( self ): return self . name class Event ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () tournament : db . ForeignKeyRelation [ Tournament ] = db . ForeignKeyField ( \"db.Tournament\" , related_name = \"events\" ) participants : db . ManyToManyRelation [ \"Team\" ] = db . ManyToManyField ( \"db.Team\" , related_name = \"events\" , through = \"event_team\" ) def __str__ ( self ): return self . name class Team ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () events : db . ManyToManyRelation [ Event ] def __str__ ( self ): return self . name @app . route ( \"/events\" ) async def events (): tournament = await Tournament . create ( name = \"tournament\" ) await Event . create ( name = \"First\" , tournament = tournament ) await Event . create ( name = \"Second\" , tournament = tournament ) tournament_with_filtered = ( await Tournament . all () . prefetch_related ( Prefetch ( \"events\" , queryset = Event . filter ( name = \"First\" ))) . first () ) print ( tournament_with_filtered ) print ( await Tournament . first () . prefetch_related ( \"events\" )) tournament_with_filtered_to_attr = ( await Tournament . all () . prefetch_related ( Prefetch ( \"events\" , queryset = Event . filter ( name = \"First\" ), to_attr = \"to_attr_events_first\" ), Prefetch ( \"events\" , queryset = Event . filter ( name = \"Second\" ), to_attr = \"to_attr_events_second\" ), ) . first () ) print ( tournament_with_filtered_to_attr . to_attr_events_first ) print ( tournament_with_filtered_to_attr . to_attr_events_second ) return 'null' if __name__ == \"__main__\" : app . run ()","title":"Prefetching"},{"location":"examples/#transactions","text":"\"\"\" This example demonstrates how you can use transactions with tortoise \"\"\" from tortoise.exceptions import OperationalError from tortoise.transactions import atomic , in_transaction class Event ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () class Meta : table = \"event\" def __str__ ( self ): return self . name @app . route ( \"/run\" ) async def run (): try : async with in_transaction () as connection : event = Event ( name = \"Test\" ) await event . save ( using_db = connection ) await Event . filter ( id = event . id ) . using_db ( connection ) . update ( name = \"Updated name\" ) saved_event = await Event . filter ( name = \"Updated name\" ) . using_db ( connection ) . first () await connection . execute_query ( \"SELECT * FROM non_existent_table\" ) except OperationalError : pass saved_event = await Event . filter ( name = \"Updated name\" ) . first () print ( saved_event ) @atomic () async def bound_to_fall (): event = await Event . create ( name = \"Test\" ) await Event . filter ( id = event . id ) . update ( name = \"Updated name\" ) saved_event = await Event . filter ( name = \"Updated name\" ) . first () print ( saved_event . name ) raise OperationalError () try : await bound_to_fall () except OperationalError : pass saved_event = await Event . filter ( name = \"Updated name\" ) . first () print ( saved_event ) return 'null' if __name__ == \"__main__\" : app . run ()","title":"Transactions"},{"location":"examples/#functions","text":"from tortoise.functions import Coalesce , Count , Length , Lower , Min , Sum , Trim , Upper from tortoise.query_utils import Q class Tournament ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () desc = db . TextField ( null = True ) events : db . ReverseRelation [ \"Event\" ] def __str__ ( self ): return self . name class Event ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () tournament : db . ForeignKeyRelation [ Tournament ] = db . ForeignKeyField ( \"models.Tournament\" , related_name = \"events\" ) participants : db . ManyToManyRelation [ \"Team\" ] = db . ManyToManyField ( \"models.Team\" , related_name = \"events\" , through = \"event_team\" ) def __str__ ( self ): return self . name class Team ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () events : db . ManyToManyRelation [ Event ] def __str__ ( self ): return self . name @app . route ( \"/runs\" ) async def run (): tournament = await Tournament . create ( name = \"New Tournament\" , desc = \"great\" ) await tournament . save () await Tournament . create ( name = \"Second tournament\" ) await Tournament . create ( name = \" final tournament \" ) await Event ( name = \"Without participants\" , tournament_id = tournament . id ) . save () event = Event ( name = \"Test\" , tournament_id = tournament . id ) await event . save () participants = [] for i in range ( 2 ): team = Team ( name = f \"Team { ( i + 1 ) } \" ) await team . save () participants . append ( team ) await event . participants . add ( participants [ 0 ], participants [ 1 ]) await event . participants . add ( participants [ 0 ], participants [ 1 ]) print ( await Tournament . all () . annotate ( events_count = Count ( \"events\" )) . filter ( events_count__gte = 1 )) print ( await Tournament . all () . annotate ( events_count_with_filter = Count ( \"events\" , _filter = Q ( name = \"New Tournament\" ))) . filter ( events_count_with_filter__gte = 1 ) ) print ( await Event . filter ( id = event . id ) . first () . annotate ( lowest_team_id = Min ( \"participants__id\" ))) print ( await Tournament . all () . annotate ( events_count = Count ( \"events\" )) . order_by ( \"events_count\" )) print ( await Event . all () . annotate ( tournament_test_id = Sum ( \"tournament__id\" )) . first ()) print ( await Tournament . annotate ( clean_desciption = Coalesce ( \"desc\" , \"\" )) . filter ( clean_desciption = \"\" ) ) print ( await Tournament . annotate ( trimmed_name = Trim ( \"name\" )) . filter ( trimmed_name = \"final tournament\" ) ) print ( await Tournament . annotate ( name_len = Length ( \"name\" )) . filter ( name_len__gt = len ( \"New Tournament\" ) ) ) print ( await Tournament . annotate ( name_lo = Lower ( \"name\" )) . filter ( name_lo = \"new tournament\" )) print ( await Tournament . annotate ( name_lo = Upper ( \"name\" )) . filter ( name_lo = \"NEW TOURNAMENT\" )) return 'null' if __name__ == \"__main__\" : app . run ()","title":"Functions"},{"location":"examples/#group-by","text":"from tortoise.functions import Avg , Count , Sum class Author ( db . Model ): name = db . CharField ( max_length = 255 ) class Book ( db . Model ): name = db . CharField ( max_length = 255 ) author = db . ForeignKeyField ( \"models.Author\" , related_name = \"books\" ) rating = db . FloatField () @app . route ( \"/runs\" ) async def run (): a1 = await Author . create ( name = \"author1\" ) a2 = await Author . create ( name = \"author2\" ) for i in range ( 10 ): await Book . create ( name = f \"book { i } \" , author = a1 , rating = i ) for i in range ( 5 ): await Book . create ( name = f \"book { i } \" , author = a2 , rating = i ) ret = await Book . annotate ( count = Count ( \"id\" )) . group_by ( \"author_id\" ) . values ( \"author_id\" , \"count\" ) print ( ret ) # >>> [{'author_id': 1, 'count': 10}, {'author_id': 2, 'count': 5}] ret = ( await Book . annotate ( count = Count ( \"id\" )) . filter ( count__gt = 6 ) . group_by ( \"author_id\" ) . values ( \"author_id\" , \"count\" ) ) print ( ret ) # >>> [{'author_id': 1, 'count': 10}] ret = await Book . annotate ( sum = Sum ( \"rating\" )) . group_by ( \"author_id\" ) . values ( \"author_id\" , \"sum\" ) print ( ret ) # >>> [{'author_id': 1, 'sum': 45.0}, {'author_id': 2, 'sum': 10.0}] ret = ( await Book . annotate ( sum = Sum ( \"rating\" )) . filter ( sum__gt = 11 ) . group_by ( \"author_id\" ) . values ( \"author_id\" , \"sum\" ) ) print ( ret ) # >>> [{'author_id': 1, 'sum': 45.0}] ret = await Book . annotate ( avg = Avg ( \"rating\" )) . group_by ( \"author_id\" ) . values ( \"author_id\" , \"avg\" ) print ( ret ) # >>> [{'author_id': 1, 'avg': 4.5}, {'author_id': 2, 'avg': 2.0}] ret = ( await Book . annotate ( avg = Avg ( \"rating\" )) . filter ( avg__gt = 3 ) . group_by ( \"author_id\" ) . values ( \"author_id\" , \"avg\" ) ) print ( ret ) # >>> [{'author_id': 1, 'avg': 4.5}] # and use .values_list() ret = ( await Book . annotate ( count = Count ( \"id\" )) . group_by ( \"author_id\" ) . values_list ( \"author_id\" , \"count\" ) ) print ( ret ) # >>> [(1, 10), (2, 5)] # group by with join ret = ( await Book . annotate ( count = Count ( \"id\" )) . group_by ( \"author__name\" ) . values ( \"author__name\" , \"count\" ) ) print ( ret ) # >>> [{\"author__name\": \"author1\", \"count\": 10}, {\"author__name\": \"author2\", \"count\": 5}] return 'null' if __name__ == \"__main__\" : app . run ()","title":"Group By"},{"location":"examples/#filtering","text":"\"\"\" This example shows some more complex querying Key points are filtering by related names and using Q objects \"\"\" from tortoise.query_utils import Q class Tournament ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () events : db . ReverseRelation [ \"Event\" ] def __str__ ( self ): return self . name class Event ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () tournament : db . ForeignKeyRelation [ Tournament ] = db . ForeignKeyField ( \"models.Tournament\" , related_name = \"events\" ) participants : db . ManyToManyRelation [ \"Team\" ] = db . ManyToManyField ( \"models.Team\" , related_name = \"events\" , through = \"event_team\" ) def __str__ ( self ): return self . name class Team ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () events : db . ManyToManyRelation [ Event ] def __str__ ( self ): return self . name @app . route ( \"/aniket\" ) async def run (): tournament = Tournament ( name = \"Tournament\" ) await tournament . save () second_tournament = Tournament ( name = \"Tournament 2\" ) await second_tournament . save () event_first = Event ( name = \"1\" , tournament = tournament ) await event_first . save () event_second = await Event . create ( name = \"2\" , tournament = second_tournament ) await Event . create ( name = \"3\" , tournament = tournament ) await Event . create ( name = \"4\" , tournament = second_tournament ) await Event . filter ( tournament = tournament ) team_first = Team ( name = \"First\" ) await team_first . save () team_second = Team ( name = \"Second\" ) await team_second . save () await team_first . events . add ( event_first ) await event_second . participants . add ( team_second ) print ( await Event . filter ( Q ( id__in = [ event_first . id , event_second . id ]) | Q ( name = \"3\" )) . filter ( participants__not = team_second . id ) . order_by ( \"tournament__id\" ) . distinct () ) print ( await Team . filter ( events__tournament_id = tournament . id ) . order_by ( \"-events__name\" )) print ( await Tournament . filter ( events__name__in = [ \"1\" , \"3\" ]) . order_by ( \"-events__participants__name\" ) . distinct () ) print ( await Team . filter ( name__icontains = \"CON\" )) print ( await Tournament . filter ( events__participants__name__startswith = \"Fir\" )) print ( await Tournament . filter ( id__icontains = 1 ) . count ()) return 'null' if __name__ == \"__main__\" : app . run ()","title":"Filtering"},{"location":"examples/#relations","text":"\"\"\" This example shows how relations between models work. Key points in this example are use of ForeignKeyField and ManyToManyField to declare relations and use of .prefetch_related() and .fetch_related() to get this related objects \"\"\" from tortoise.exceptions import NoValuesFetched class Tournament ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () events : db . ReverseRelation [ \"Event\" ] def __str__ ( self ): return self . name class Event ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () tournament : db . ForeignKeyRelation [ Tournament ] = db . ForeignKeyField ( \"models.Tournament\" , related_name = \"events\" ) participants : db . ManyToManyRelation [ \"Team\" ] = db . ManyToManyField ( \"models.Team\" , related_name = \"events\" , through = \"event_team\" ) def __str__ ( self ): return self . name class Address ( db . Model ): city = db . CharField ( max_length = 64 ) street = db . CharField ( max_length = 128 ) event : db . OneToOneRelation [ Event ] = db . OneToOneField ( \"models.Event\" , on_delete = db . CASCADE , related_name = \"address\" , pk = True ) def __str__ ( self ): return f \"Address( { self . city } , { self . street } )\" class Team ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () events : db . ManyToManyRelation [ Event ] def __str__ ( self ): return self . name @app . route ( \"/verloop\" ) async def run (): tournament = Tournament ( name = \"New Tournament\" ) await tournament . save () await Event ( name = \"Without participants\" , tournament_id = tournament . id ) . save () event = Event ( name = \"Test\" , tournament_id = tournament . id ) await event . save () await Address . create ( city = \"Santa Monica\" , street = \"Ocean\" , event = event ) participants = [] for i in range ( 2 ): team = Team ( name = f \"Team { ( i + 1 ) } \" ) await team . save () participants . append ( team ) await event . participants . add ( participants [ 0 ], participants [ 1 ]) await event . participants . add ( participants [ 0 ], participants [ 1 ]) try : for team in event . participants : print ( team . id ) except NoValuesFetched : pass async for team in event . participants : print ( team . id ) for team in event . participants : print ( team . id ) print ( await Event . filter ( participants = participants [ 0 ] . id ) . prefetch_related ( \"participants\" , \"tournament\" ) ) print ( await participants [ 0 ] . fetch_related ( \"events\" )) print ( await Team . fetch_for_list ( participants , \"events\" )) print ( await Team . filter ( events__tournament__id = tournament . id )) print ( await Event . filter ( tournament = tournament )) print ( await Tournament . filter ( events__name__in = [ \"Test\" , \"Prod\" ]) . order_by ( \"-events__participants__name\" ) . distinct () ) print ( await Event . filter ( id = event . id ) . values ( \"id\" , \"name\" , tournament = \"tournament__name\" )) print ( await Event . filter ( id = event . id ) . values_list ( \"id\" , \"participants__name\" )) print ( await Address . filter ( event = event ) . first ()) event_reload1 = await Event . filter ( id = event . id ) . first () print ( await event_reload1 . address ) event_reload2 = await Event . filter ( id = event . id ) . prefetch_related ( \"address\" ) . first () print ( event_reload2 . address ) return 'null' if __name__ == \"__main__\" : app . run ()","title":"Relations"},{"location":"examples/#relations-with-unique-field","text":"\"\"\" This example shows how relations between models especially unique field work. Key points in this example are use of ForeignKeyField and OneToOneField has to_field. For other basic parts, it is the same as relation exmaple. \"\"\" from tortoise.query_utils import Prefetch class School ( db . Model ): uuid = db . UUIDField ( pk = True ) name = db . TextField () id = db . IntField ( unique = True ) students : db . ReverseRelation [ \"Student\" ] principal : db . ReverseRelation [ \"Principal\" ] class Student ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () school : db . ForeignKeyRelation [ School ] = db . ForeignKeyField ( \"models.School\" , related_name = \"students\" , to_field = \"id\" ) class Principal ( db . Model ): id = db . IntField ( pk = True ) name = db . TextField () school : db . OneToOneRelation [ School ] = db . OneToOneField ( \"models.School\" , on_delete = db . CASCADE , related_name = \"principal\" , to_field = \"id\" ) @app . route ( \"/forloop\" ) async def run (): school1 = await School . create ( id = 1024 , name = \"School1\" ) student1 = await Student . create ( name = \"Sang-Heon Jeon1\" , school_id = school1 . id ) student_schools = await Student . filter ( name = \"Sang-Heon Jeon1\" ) . values ( \"name\" , \"school__name\" ) print ( student_schools [ 0 ]) await Student . create ( name = \"Sang-Heon Jeon2\" , school = school1 ) school_with_filtered = ( await School . all () . prefetch_related ( Prefetch ( \"students\" , queryset = Student . filter ( name = \"Sang-Heon Jeon1\" ))) . first () ) school_without_filtered = await School . first () . prefetch_related ( \"students\" ) print ( len ( school_with_filtered . students )) print ( len ( school_without_filtered . students )) school2 = await School . create ( id = 2048 , name = \"School2\" ) await Student . all () . update ( school = school2 ) student = await Student . first () print ( student . school_id ) await Student . filter ( id = student1 . id ) . update ( school = school1 ) schools = await School . all () . order_by ( \"students__name\" ) print ([ school . name for school in schools ]) fetched_principal = await Principal . create ( name = \"Sang-Heon Jeon3\" , school = school1 ) print ( fetched_principal . name ) fetched_school = await School . filter ( name = \"School1\" ) . prefetch_related ( \"principal\" ) . first () print ( fetched_school . name ) return 'null' if __name__ == \"__main__\" : app . run ()","title":"Relations with Unique field"},{"location":"examples/#recursive-relations","text":"\"\"\" This example shows how self-referential (recursive) relations work. Key points in this example are: * Use of ForeignKeyField that refers to self * To pass in the (optional) parent node at creation * To use async iterator to fetch children * To use .fetch_related(\u2026) to emulate sync behaviour * That insert-order gets preserved for ForeignFields, but not ManyToManyFields \"\"\" class Employee ( db . Model ): name = db . CharField ( max_length = 50 ) manager : db . ForeignKeyNullableRelation [ \"Employee\" ] = db . ForeignKeyField ( \"models.Employee\" , related_name = \"team_members\" , null = True ) team_members : db . ReverseRelation [ \"Employee\" ] talks_to : db . ManyToManyRelation [ \"Employee\" ] = db . ManyToManyField ( \"models.Employee\" , related_name = \"gets_talked_to\" ) gets_talked_to : db . ManyToManyRelation [ \"Employee\" ] def __str__ ( self ): return self . name async def full_hierarchy__async_for ( self , level = 0 ): \"\"\" Demonstrates ``async for` to fetch relations An async iterator will fetch the relationship on-demand. \"\"\" text = [ \" {}{} (to: {} ) (from: {} )\" . format ( level * \" \" , self , \", \" . join ([ str ( val ) async for val in self . talks_to ]), \", \" . join ([ str ( val ) async for val in self . gets_talked_to ]), ) ] async for member in self . team_members : text . append ( await member . full_hierarchy__async_for ( level + 1 )) return \" \\n \" . join ( text ) async def full_hierarchy__fetch_related ( self , level = 0 ): \"\"\" Demonstrates ``await .fetch_related`` to fetch relations On prefetching the data, the relationship files will contain a regular list. This is how one would get relations working on sync serialization/templating frameworks. \"\"\" await self . fetch_related ( \"team_members\" , \"talks_to\" , \"gets_talked_to\" ) text = [ \" {}{} (to: {} ) (from: {} )\" . format ( level * \" \" , self , \", \" . join ([ str ( val ) for val in self . talks_to ]), \", \" . join ([ str ( val ) for val in self . gets_talked_to ]), ) ] for member in self . team_members : text . append ( await member . full_hierarchy__fetch_related ( level + 1 )) return \" \\n \" . join ( text ) @app . route ( \"/relationer\" ) async def run (): root = await Employee . create ( name = \"Root\" ) loose = await Employee . create ( name = \"Loose\" ) _1 = await Employee . create ( name = \"1. First H1\" , manager = root ) _2 = await Employee . create ( name = \"2. Second H1\" , manager = root ) _1_1 = await Employee . create ( name = \"1.1. First H2\" , manager = _1 ) _1_1_1 = await Employee . create ( name = \"1.1.1. First H3\" , manager = _1_1 ) _2_1 = await Employee . create ( name = \"2.1. Second H2\" , manager = _2 ) _2_2 = await Employee . create ( name = \"2.2. Third H2\" , manager = _2 ) await _1 . talks_to . add ( _2 , _1_1_1 , loose ) await _2_1 . gets_talked_to . add ( _2_2 , _1_1 , loose ) # Evaluated off creation objects print ( await loose . full_hierarchy__fetch_related ()) print ( await root . full_hierarchy__async_for ()) print ( await root . full_hierarchy__fetch_related ()) # Evaluated off new objects \u2192 Result is identical root2 = await Employee . get ( name = \"Root\" ) loose2 = await Employee . get ( name = \"Loose\" ) print ( await loose2 . full_hierarchy__fetch_related ()) print ( await root2 . full_hierarchy__async_for ()) print ( await root2 . full_hierarchy__fetch_related ()) return 'null' if __name__ == \"__main__\" : app . run ()","title":"Recursive relations"},{"location":"queryset/","text":"QuerySet \u00b6 Introduction \u00b6 Tortoise-ORM provides a reach service of the query by using the class tortoise.queryset.QuerySet . Here in this Flask-Tortoise module I have inherited the default tortoise.queryset.QuerySet and added some extra query methods. To check all the inbuild available queries, please visit at: https://tortoise-orm.readthedocs.io/en/latest/query.html Custom Query \u00b6 To use the custom queries you have to change the meta.manager class for a Model . How to add custom manager class with Model \u00b6 from flask_tortoise import Tortoise , fields from flask_tortoise.models import Manager db = Tortoise () class Users ( db . Model ): id = fields . IntField ( pk = True ) name = fields . CharField ( 20 , null = True ) status = fields . CharField ( 20 ) class Meta : manager = Manager () the above process will add a custom manager with your model. And this custom manager will provide the extra query methods. Available custom methods \u00b6 get_or_404 \u00b6 Fetch exactly one object matching the parameters or raise 404 not found error. Parameters \u00b6 args: Q functions containing constraints. Will be AND'ed. kwargs: Simple filter constraints. description: Error description. Example: \u00b6 @app . get ( \"/data\" ) async def get_data (): pk = 17 user = await Users . get_or_404 ( pk = pk , description = f \"user object not found at ID: { pk } \" ) return jsonify ( name = str ( user )) first_or_404 \u00b6 Like method first but aborts with 404 if not found instead of returning None . Parameters \u00b6 args: Q functions containing constraints. Will be AND'ed. kwargs: Simple filter constraints. Examples \u00b6 @app . get ( \"/data-1\" ) async def get_data_one (): pk = 17 user = await Users . first_or_404 ( pk = pk , description = f \"user object not found at ID: { pk } \" ) return jsonify ( name = str ( user )) pagination \u00b6 The pagination support just like the flask-sqlalchemy . This features is still under development. Jinja2 requires teh support of async functions to do this.","title":"QuerySet"},{"location":"queryset/#queryset","text":"","title":"QuerySet"},{"location":"queryset/#introduction","text":"Tortoise-ORM provides a reach service of the query by using the class tortoise.queryset.QuerySet . Here in this Flask-Tortoise module I have inherited the default tortoise.queryset.QuerySet and added some extra query methods. To check all the inbuild available queries, please visit at: https://tortoise-orm.readthedocs.io/en/latest/query.html","title":"Introduction"},{"location":"queryset/#custom-query","text":"To use the custom queries you have to change the meta.manager class for a Model .","title":"Custom Query"},{"location":"queryset/#how-to-add-custom-manager-class-with-model","text":"from flask_tortoise import Tortoise , fields from flask_tortoise.models import Manager db = Tortoise () class Users ( db . Model ): id = fields . IntField ( pk = True ) name = fields . CharField ( 20 , null = True ) status = fields . CharField ( 20 ) class Meta : manager = Manager () the above process will add a custom manager with your model. And this custom manager will provide the extra query methods.","title":"How to add custom manager class with Model"},{"location":"queryset/#available-custom-methods","text":"","title":"Available custom methods"},{"location":"queryset/#get_or_404","text":"Fetch exactly one object matching the parameters or raise 404 not found error.","title":"get_or_404"},{"location":"queryset/#parameters","text":"args: Q functions containing constraints. Will be AND'ed. kwargs: Simple filter constraints. description: Error description.","title":"Parameters"},{"location":"queryset/#example","text":"@app . get ( \"/data\" ) async def get_data (): pk = 17 user = await Users . get_or_404 ( pk = pk , description = f \"user object not found at ID: { pk } \" ) return jsonify ( name = str ( user ))","title":"Example:"},{"location":"queryset/#first_or_404","text":"Like method first but aborts with 404 if not found instead of returning None .","title":"first_or_404"},{"location":"queryset/#parameters_1","text":"args: Q functions containing constraints. Will be AND'ed. kwargs: Simple filter constraints.","title":"Parameters"},{"location":"queryset/#examples","text":"@app . get ( \"/data-1\" ) async def get_data_one (): pk = 17 user = await Users . first_or_404 ( pk = pk , description = f \"user object not found at ID: { pk } \" ) return jsonify ( name = str ( user ))","title":"Examples"},{"location":"queryset/#pagination","text":"The pagination support just like the flask-sqlalchemy . This features is still under development. Jinja2 requires teh support of async functions to do this.","title":"pagination"},{"location":"tutorial/","text":"Tutorial \u00b6 Introduction \u00b6 The basic introdunction provides you a basic understanding of the Flask-Tortoise module. Primary entity of tortoise is flask_tortoise.models.Model. You can start writing models like this: from flask_tortoise.models import Tortoise , fields db : \"Tortoise\" = Tortoise () class Tournament ( db . Model ): # Defining `id` field is optional, it will be defined automatically # if you haven't done it yourself id = fields . IntField ( pk = True ) name = fields . CharField ( max_length = 255 ) # Defining ``__str__`` is also optional, but gives you pretty # represent of model in debugger and interpreter def __str__ ( self ): return self . name class Event ( db . Model ): id = fields . IntField ( pk = True ) name = fields . CharField ( max_length = 255 ) # References to other models are defined in format # \"{app_name}.{model_name}\" - where {app_name} is defined in tortoise config tournament = fields . ForeignKeyField ( 'models.Tournament' , related_name = 'events' ) participants = fields . ManyToManyField ( 'models.Team' , related_name = 'events' , through = 'event_team' ) def __str__ ( self ): return self . name class Team ( db . Model ): id = fields . IntField ( pk = True ) name = fields . CharField ( max_length = 255 ) def __str__ ( self ): return self . name After you defined all your models, tortoise needs you to init them, in order to create backward relations between models and match your db client with appropriate models. You can do it like this: from .models import * from flask import Flask app = Flask ( __name__ ) db . init_app ( app ) if __name__ == '__main__' : app . run () Here init_app method will connect the flask application with the Tortoise ORM . Tortoise is the asynchronous based database. So the database connection must to close on every request end. So this module will initialize the Tortoise ORM before on every request and close it after the reqyest end. After that you can start using your models: # Create instance by save tournament = Tournament ( name = 'New Tournament' ) await tournament . save () # Or by .create() await Event . create ( name = 'Without participants' , tournament = tournament ) event = await Event . create ( name = 'Test' , tournament = tournament ) participants = [] for i in range ( 2 ): team = await Team . create ( name = 'Team {} ' . format ( i + 1 )) participants . append ( team ) # M2M Relationship management is quite straightforward # (look for methods .remove(...) and .clear()) await event . participants . add ( * participants ) # You can query related entity just with async for async for team in event . participants : pass # After making related query you can iterate with regular for, # which can be extremely convenient for using with other packages, # for example some kind of serializers with nested support for team in event . participants : pass # Or you can make preemptive call to fetch related objects, # so you can work with related objects immediately selected_events = await Event . filter ( participants = participants [ 0 ] . id ) . prefetch_related ( 'participants' , 'tournament' ) for event in selected_events : print ( event . tournament . name ) print ([ t . name for t in event . participants ]) # Tortoise ORM supports variable depth of prefetching related entities # This will fetch all events for team and in those team tournament will be prefetched await Team . all () . prefetch_related ( 'events__tournament' ) # You can filter and order by related models too await Tournament . filter ( events__name__in = [ 'Test' , 'Prod' ] ) . order_by ( '-events__participants__name' ) . distinct () Note: For more please visit the official documentation of Tortoise ORM at: https://tortoise-orm.readthedocs.io/en/latest/getting_started.html#tutorial","title":"Tutorial"},{"location":"tutorial/#tutorial","text":"","title":"Tutorial"},{"location":"tutorial/#introduction","text":"The basic introdunction provides you a basic understanding of the Flask-Tortoise module. Primary entity of tortoise is flask_tortoise.models.Model. You can start writing models like this: from flask_tortoise.models import Tortoise , fields db : \"Tortoise\" = Tortoise () class Tournament ( db . Model ): # Defining `id` field is optional, it will be defined automatically # if you haven't done it yourself id = fields . IntField ( pk = True ) name = fields . CharField ( max_length = 255 ) # Defining ``__str__`` is also optional, but gives you pretty # represent of model in debugger and interpreter def __str__ ( self ): return self . name class Event ( db . Model ): id = fields . IntField ( pk = True ) name = fields . CharField ( max_length = 255 ) # References to other models are defined in format # \"{app_name}.{model_name}\" - where {app_name} is defined in tortoise config tournament = fields . ForeignKeyField ( 'models.Tournament' , related_name = 'events' ) participants = fields . ManyToManyField ( 'models.Team' , related_name = 'events' , through = 'event_team' ) def __str__ ( self ): return self . name class Team ( db . Model ): id = fields . IntField ( pk = True ) name = fields . CharField ( max_length = 255 ) def __str__ ( self ): return self . name After you defined all your models, tortoise needs you to init them, in order to create backward relations between models and match your db client with appropriate models. You can do it like this: from .models import * from flask import Flask app = Flask ( __name__ ) db . init_app ( app ) if __name__ == '__main__' : app . run () Here init_app method will connect the flask application with the Tortoise ORM . Tortoise is the asynchronous based database. So the database connection must to close on every request end. So this module will initialize the Tortoise ORM before on every request and close it after the reqyest end. After that you can start using your models: # Create instance by save tournament = Tournament ( name = 'New Tournament' ) await tournament . save () # Or by .create() await Event . create ( name = 'Without participants' , tournament = tournament ) event = await Event . create ( name = 'Test' , tournament = tournament ) participants = [] for i in range ( 2 ): team = await Team . create ( name = 'Team {} ' . format ( i + 1 )) participants . append ( team ) # M2M Relationship management is quite straightforward # (look for methods .remove(...) and .clear()) await event . participants . add ( * participants ) # You can query related entity just with async for async for team in event . participants : pass # After making related query you can iterate with regular for, # which can be extremely convenient for using with other packages, # for example some kind of serializers with nested support for team in event . participants : pass # Or you can make preemptive call to fetch related objects, # so you can work with related objects immediately selected_events = await Event . filter ( participants = participants [ 0 ] . id ) . prefetch_related ( 'participants' , 'tournament' ) for event in selected_events : print ( event . tournament . name ) print ([ t . name for t in event . participants ]) # Tortoise ORM supports variable depth of prefetching related entities # This will fetch all events for team and in those team tournament will be prefetched await Team . all () . prefetch_related ( 'events__tournament' ) # You can filter and order by related models too await Tournament . filter ( events__name__in = [ 'Test' , 'Prod' ] ) . order_by ( '-events__participants__name' ) . distinct () Note: For more please visit the official documentation of Tortoise ORM at: https://tortoise-orm.readthedocs.io/en/latest/getting_started.html#tutorial","title":"Introduction"}]}