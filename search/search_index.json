{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Flask-Tortoise - Asynchronous database support for Flask \u00b6 Documentation: https://navycut.github.io Github Repo: https://github.com/navycut/navycut Introduction \u00b6 Flask-Tortoise is an extension for Flask that adds support for asynchronous Tortoise-ORM to your application with in-built migration system. It aims to simplify using Tortoise-ORM with Flask by providing useful defaults and extra helpers that make it easier to accomplish common tasks. Tortoise-ORM is one of the best tool to interact with the database asynchronously. It's clean and Django type implementation provides you a better view and understanding of the database ORM system. Also you can use the Pydantic data module to write the error-less code. The main aim of Tortoise-ORM is to provide the same service and api like the Django-ORM . Installation \u00b6 Install or update from PYPI \u00b6 pip install -U Flask-Tortoise Install from source code \u00b6 $ git clone https://github.com/marktennyson/Flask-Tortoise $ cd Flask-Tortoise && pip install . Features \u00b6 Fully asynchronous support. Clean, familiar python interface. Pluggable Database backends. Reach query system like Django. Composable, Django-inspired Models Proper implementation of different types of relation fields. Extra QuerySet added and pagination support. please check the official documentation of Tortoise-ORM for more details at: https://tortoise-orm.readthedocs.io/en/latest/ Available configs \u00b6 TORTOISE_ORM_DATABASE_URI: ad the database url here. Mandatory field Type: str TORTOISE_ORM_MODELS: add the name of the all model file. Default value: app.import_name Type: str TORTOISE_ORM_MODULES: add the tortoise orm module dict here if you are about to initialize it by modules. Default value: {} Type: dict TORTOISE_ORM_CONFIG: Initialize the tortoise Orm with the config dictionary. Default value: {} Type: dict TORTOISE_ORM_CONFIG_FILE: Initialize the tortoise orm from a config file. Default value: None Type: optional-str TORTOISE_ORM_GENERATE_SCHEMAS: generate the schemas at the time of tortoise orm initialization. Default value: False Type: bool A Basic demo for better understanding \u00b6 from flask import Flask , jsonify from flask_tortoise import Tortoise , Model , fields from random import choice STATUSES = [ \"New\" , \"Old\" , \"Gone\" ] app : \"Flask\" = Flask ( __name__ ) app . config [ 'TORTOISE_ORM_DATABASE_URI' ] = 'sqlite://db.sqlite3' db : \"Tortoise\" = Tortoise ( app ) class Users ( Model ): id = fields . IntField ( pk = True ) status = fields . CharField ( 20 ) def __str__ ( self ): return f \"User { self . id } : { self . status } \" class Workers ( Model ): id = fields . IntField ( pk = True ) status = fields . CharField ( 20 ) def __str__ ( self ): return f \"Worker { self . id } : { self . status } \" @app . get ( \"/\" ) async def list_all (): users = await Users . all () workers = await Workers . all () return jsonify ( { \"users\" : [ str ( user ) for user in users ], \"workers\" : [ str ( worker ) for worker in workers ]} ) @app . get ( \"/user\" ) async def add_user (): user = await Users . create ( status = choice ( STATUSES )) # nosec return str ( user ) @app . get ( \"/worker\" ) async def add_worker (): worker = await Workers . create ( status = choice ( STATUSES )) # nosec return str ( worker ) @app . get ( \"/get-worker\" ) async def get_worker (): worker : \"Workers\" = await Workers . get ( id = 1 ) return str ( worker . status ) if __name__ == '__main__' : app . run ( debug = True , port = 8080 ) If you save your models into a separate file than you have mention the file name on app config: let's assume you have stores all of your models at models.py file. models.py file: from flask_tortoise import Tortoise , Model , fields db : \"Tortoise\" = Tortoise () class Users ( Model ): id = fields . IntField ( pk = True ) status = fields . CharField ( 20 ) def __str__ ( self ): return f \"User { self . id } : { self . status } \" class Workers ( Model ): id = fields . IntField ( pk = True ) status = fields . CharField ( 20 ) def __str__ ( self ): return f \"Worker { self . id } : { self . status } \" app.py file: from flask import Flask , jsonify from models import * from random import choice STATUSES = [ \"New\" , \"Old\" , \"Gone\" ] app : \"Flask\" = Flask ( __name__ ) app . config [ 'TORTOISE_ORM_DATABASE_URI' ] = 'sqlite://db.sqlite3' app . config [ 'TORTOISE_ORM_MODELS' ] = \"models\" # if you have more than one models file then : [\"models_1\", \"models_2\", \"models_3\"] db . init_app ( app ) @app . get ( \"/\" ) async def list_all (): users = await Users . all () workers = await Workers . all () return jsonify ( { \"users\" : [ str ( user ) for user in users ], \"workers\" : [ str ( worker ) for worker in workers ]} ) @app . get ( \"/user\" ) async def add_user (): user = await Users . create ( status = choice ( STATUSES )) # nosec return str ( user ) @app . get ( \"/worker\" ) async def add_worker (): worker = await Workers . create ( status = choice ( STATUSES )) # nosec return str ( worker ) @app . get ( \"/get-worker\" ) async def get_worker (): worker : \"Workers\" = await Workers . get ( id = 1 ) return str ( worker . status ) if __name__ == '__main__' : app . run ( debug = True , port = 8080 )","title":"Flask-Tortoise"},{"location":"#flask-tortoise-asynchronous-database-support-for-flask","text":"Documentation: https://navycut.github.io Github Repo: https://github.com/navycut/navycut","title":"Flask-Tortoise - Asynchronous database support for Flask"},{"location":"#introduction","text":"Flask-Tortoise is an extension for Flask that adds support for asynchronous Tortoise-ORM to your application with in-built migration system. It aims to simplify using Tortoise-ORM with Flask by providing useful defaults and extra helpers that make it easier to accomplish common tasks. Tortoise-ORM is one of the best tool to interact with the database asynchronously. It's clean and Django type implementation provides you a better view and understanding of the database ORM system. Also you can use the Pydantic data module to write the error-less code. The main aim of Tortoise-ORM is to provide the same service and api like the Django-ORM .","title":"Introduction"},{"location":"#installation","text":"","title":"Installation"},{"location":"#install-or-update-from-pypi","text":"pip install -U Flask-Tortoise","title":"Install or update from PYPI"},{"location":"#install-from-source-code","text":"$ git clone https://github.com/marktennyson/Flask-Tortoise $ cd Flask-Tortoise && pip install .","title":"Install from source code"},{"location":"#features","text":"Fully asynchronous support. Clean, familiar python interface. Pluggable Database backends. Reach query system like Django. Composable, Django-inspired Models Proper implementation of different types of relation fields. Extra QuerySet added and pagination support. please check the official documentation of Tortoise-ORM for more details at: https://tortoise-orm.readthedocs.io/en/latest/","title":"Features"},{"location":"#available-configs","text":"TORTOISE_ORM_DATABASE_URI: ad the database url here. Mandatory field Type: str TORTOISE_ORM_MODELS: add the name of the all model file. Default value: app.import_name Type: str TORTOISE_ORM_MODULES: add the tortoise orm module dict here if you are about to initialize it by modules. Default value: {} Type: dict TORTOISE_ORM_CONFIG: Initialize the tortoise Orm with the config dictionary. Default value: {} Type: dict TORTOISE_ORM_CONFIG_FILE: Initialize the tortoise orm from a config file. Default value: None Type: optional-str TORTOISE_ORM_GENERATE_SCHEMAS: generate the schemas at the time of tortoise orm initialization. Default value: False Type: bool","title":"Available configs"},{"location":"#a-basic-demo-for-better-understanding","text":"from flask import Flask , jsonify from flask_tortoise import Tortoise , Model , fields from random import choice STATUSES = [ \"New\" , \"Old\" , \"Gone\" ] app : \"Flask\" = Flask ( __name__ ) app . config [ 'TORTOISE_ORM_DATABASE_URI' ] = 'sqlite://db.sqlite3' db : \"Tortoise\" = Tortoise ( app ) class Users ( Model ): id = fields . IntField ( pk = True ) status = fields . CharField ( 20 ) def __str__ ( self ): return f \"User { self . id } : { self . status } \" class Workers ( Model ): id = fields . IntField ( pk = True ) status = fields . CharField ( 20 ) def __str__ ( self ): return f \"Worker { self . id } : { self . status } \" @app . get ( \"/\" ) async def list_all (): users = await Users . all () workers = await Workers . all () return jsonify ( { \"users\" : [ str ( user ) for user in users ], \"workers\" : [ str ( worker ) for worker in workers ]} ) @app . get ( \"/user\" ) async def add_user (): user = await Users . create ( status = choice ( STATUSES )) # nosec return str ( user ) @app . get ( \"/worker\" ) async def add_worker (): worker = await Workers . create ( status = choice ( STATUSES )) # nosec return str ( worker ) @app . get ( \"/get-worker\" ) async def get_worker (): worker : \"Workers\" = await Workers . get ( id = 1 ) return str ( worker . status ) if __name__ == '__main__' : app . run ( debug = True , port = 8080 ) If you save your models into a separate file than you have mention the file name on app config: let's assume you have stores all of your models at models.py file. models.py file: from flask_tortoise import Tortoise , Model , fields db : \"Tortoise\" = Tortoise () class Users ( Model ): id = fields . IntField ( pk = True ) status = fields . CharField ( 20 ) def __str__ ( self ): return f \"User { self . id } : { self . status } \" class Workers ( Model ): id = fields . IntField ( pk = True ) status = fields . CharField ( 20 ) def __str__ ( self ): return f \"Worker { self . id } : { self . status } \" app.py file: from flask import Flask , jsonify from models import * from random import choice STATUSES = [ \"New\" , \"Old\" , \"Gone\" ] app : \"Flask\" = Flask ( __name__ ) app . config [ 'TORTOISE_ORM_DATABASE_URI' ] = 'sqlite://db.sqlite3' app . config [ 'TORTOISE_ORM_MODELS' ] = \"models\" # if you have more than one models file then : [\"models_1\", \"models_2\", \"models_3\"] db . init_app ( app ) @app . get ( \"/\" ) async def list_all (): users = await Users . all () workers = await Workers . all () return jsonify ( { \"users\" : [ str ( user ) for user in users ], \"workers\" : [ str ( worker ) for worker in workers ]} ) @app . get ( \"/user\" ) async def add_user (): user = await Users . create ( status = choice ( STATUSES )) # nosec return str ( user ) @app . get ( \"/worker\" ) async def add_worker (): worker = await Workers . create ( status = choice ( STATUSES )) # nosec return str ( worker ) @app . get ( \"/get-worker\" ) async def get_worker (): worker : \"Workers\" = await Workers . get ( id = 1 ) return str ( worker . status ) if __name__ == '__main__' : app . run ( debug = True , port = 8080 )","title":"A Basic demo for better understanding"},{"location":"cli/","text":"Command Line Interface to Migrate the Database \u00b6 Introduction \u00b6 This document describes how to use the command line to make migrations while using Flask-Tortoise . Internally it's using Aerich module to provide the migration support. Special thanks to the author of Aerich module. Quick Start \u00b6 Flask-Tortoise module is connected to the flask.Flask.cli click-group. So you can use the command line as same as the other flask extensions. $ flask tortoise --help Usage: flask tortoise [ OPTIONS ] COMMAND [ ARGS ] ... the default command line interface to manage the version of the tortoise orm. Options: -h, --help Show this message and exit. Commands: downgrade Downgrade to specified version. heads Show current available heads in migrate location. history List all migrate items. init Initialize the orm. init-db Generate schema and generate app migrate location. inspectdb Introspects the database tables to standard output as... migrate Generate migrate changes file. upgrade Upgrade to specified version. Usage \u00b6 Initialization \u00b6 $ flask tortoise init --help Usage: flask tortoise init [ OPTIONS ] Init config file and generate root migrate location. Options: -t, --tortoise-orm TEXT Tortoise-ORM config module dict variable, like settings.TORTOISE_ORM. [ required ] --location TEXT Migrate store location. [ default: ./migrations ] -h, --help Show this message and exit. Init DB \u00b6 $ flask tortoise init-db Success create app migrate location ./migrations/models Success generate schema for app \"models\" Note: If your models not present at the __main__ file then you must need to pass the models file name at the app config: TORTOISE_DATABASE_MODLES . Update models and make migrate \u00b6 $ flask tortoise migrate --name drop_column Success migrate 1_202029051520102929_drop_column.sql Format of migrate filename is {version_num} {datetime} .sql. And if it guess you are renaming a column, it will ask Rename {old_column} to {new_column} [True], you can choice True to rename column without column drop, or choice False to drop column then create. If you use MySQL, only MySQL8.0+ support rename..to syntax. Upgrade to latest version \u00b6 $ flask tortoise upgrade Success upgrade 1_202029051520102929_drop_column.sql Now your db is migrated to latest. Downgrade to specified version \u00b6 $ flask tortoise downgrade --help Usage: flask tortoise downgrade [ OPTIONS ] Downgrade to specified version. Options: -v, --version INTEGER Specified version, default to last. [ default: -1 ] -d, --delete Delete version files at the same time. [ default: False ] -h, --help Show this message and exit. $ flask tortoise downgrade Success downgrade 1_202029051520102929_drop_column.sql Now your db rollback to specified version. Show history \u00b6 $ flask tortoise history 1_202029051520102929_drop_column.sql Show heads to be migrated \u00b6 $ aerich heads 1_202029051520102929_drop_column.sql","title":"Command Line"},{"location":"cli/#command-line-interface-to-migrate-the-database","text":"","title":"Command Line Interface to Migrate the Database"},{"location":"cli/#introduction","text":"This document describes how to use the command line to make migrations while using Flask-Tortoise . Internally it's using Aerich module to provide the migration support. Special thanks to the author of Aerich module.","title":"Introduction"},{"location":"cli/#quick-start","text":"Flask-Tortoise module is connected to the flask.Flask.cli click-group. So you can use the command line as same as the other flask extensions. $ flask tortoise --help Usage: flask tortoise [ OPTIONS ] COMMAND [ ARGS ] ... the default command line interface to manage the version of the tortoise orm. Options: -h, --help Show this message and exit. Commands: downgrade Downgrade to specified version. heads Show current available heads in migrate location. history List all migrate items. init Initialize the orm. init-db Generate schema and generate app migrate location. inspectdb Introspects the database tables to standard output as... migrate Generate migrate changes file. upgrade Upgrade to specified version.","title":"Quick Start"},{"location":"cli/#usage","text":"","title":"Usage"},{"location":"cli/#initialization","text":"$ flask tortoise init --help Usage: flask tortoise init [ OPTIONS ] Init config file and generate root migrate location. Options: -t, --tortoise-orm TEXT Tortoise-ORM config module dict variable, like settings.TORTOISE_ORM. [ required ] --location TEXT Migrate store location. [ default: ./migrations ] -h, --help Show this message and exit.","title":"Initialization"},{"location":"cli/#init-db","text":"$ flask tortoise init-db Success create app migrate location ./migrations/models Success generate schema for app \"models\" Note: If your models not present at the __main__ file then you must need to pass the models file name at the app config: TORTOISE_DATABASE_MODLES .","title":"Init DB"},{"location":"cli/#update-models-and-make-migrate","text":"$ flask tortoise migrate --name drop_column Success migrate 1_202029051520102929_drop_column.sql Format of migrate filename is {version_num} {datetime} .sql. And if it guess you are renaming a column, it will ask Rename {old_column} to {new_column} [True], you can choice True to rename column without column drop, or choice False to drop column then create. If you use MySQL, only MySQL8.0+ support rename..to syntax.","title":"Update models and make migrate"},{"location":"cli/#upgrade-to-latest-version","text":"$ flask tortoise upgrade Success upgrade 1_202029051520102929_drop_column.sql Now your db is migrated to latest.","title":"Upgrade to latest version"},{"location":"cli/#downgrade-to-specified-version","text":"$ flask tortoise downgrade --help Usage: flask tortoise downgrade [ OPTIONS ] Downgrade to specified version. Options: -v, --version INTEGER Specified version, default to last. [ default: -1 ] -d, --delete Delete version files at the same time. [ default: False ] -h, --help Show this message and exit. $ flask tortoise downgrade Success downgrade 1_202029051520102929_drop_column.sql Now your db rollback to specified version.","title":"Downgrade to specified version"},{"location":"cli/#show-history","text":"$ flask tortoise history 1_202029051520102929_drop_column.sql","title":"Show history"},{"location":"cli/#show-heads-to-be-migrated","text":"$ aerich heads 1_202029051520102929_drop_column.sql","title":"Show heads to be migrated"},{"location":"examples/","text":"","title":"Examples"},{"location":"queryset/","text":"QuerySet \u00b6 Introduction \u00b6 Tortoise-ORM provides a reach service of the query by using the class tortoise.queryset.QuerySet . Here in this Flask-Tortoise module I have inherited the default tortoise.queryset.QuerySet and added some extra query methods. To check all the inbuild available queries, please visit at: https://tortoise-orm.readthedocs.io/en/latest/query.html Custom Query \u00b6 To use the custom queries you have to change the meta.manager class for a Model . How to add custom manager class with Model \u00b6 from flask_tortoise import Tortoise , fields from flask_tortoise.models import Manager db = Tortoise () class Users ( db . Model ): id = fields . IntField ( pk = True ) name = fields . CharField ( 20 , null = True ) status = fields . CharField ( 20 ) class Meta : manager = Manager () the above process will add a custom manager with your model. And this custom manager will provide the extra query methods. Available custom methods \u00b6 get_or_404 \u00b6 Fetch exactly one object matching the parameters or raise 404 not found error. Parameters \u00b6 args: Q functions containing constraints. Will be AND'ed. kwargs: Simple filter constraints. description: Error description. Example: \u00b6 @app . get ( \"/data\" ) async def get_data (): pk = 17 user = await Users . get_or_404 ( pk = pk , description = f \"user object not found at ID: { pk } \" ) return jsonify ( name = str ( user )) first_or_404 \u00b6 Like method first but aborts with 404 if not found instead of returning None . Parameters \u00b6 args: Q functions containing constraints. Will be AND'ed. kwargs: Simple filter constraints. Examples \u00b6 @app . get ( \"/data-1\" ) async def get_data_one (): pk = 17 user = await Users . first_or_404 ( pk = pk , description = f \"user object not found at ID: { pk } \" ) return jsonify ( name = str ( user )) pagination \u00b6 The pagination support just like the flask-sqlalchemy . This features is still under development. Jinja2 requires teh support of async functions to do this.","title":"QuerySet"},{"location":"queryset/#queryset","text":"","title":"QuerySet"},{"location":"queryset/#introduction","text":"Tortoise-ORM provides a reach service of the query by using the class tortoise.queryset.QuerySet . Here in this Flask-Tortoise module I have inherited the default tortoise.queryset.QuerySet and added some extra query methods. To check all the inbuild available queries, please visit at: https://tortoise-orm.readthedocs.io/en/latest/query.html","title":"Introduction"},{"location":"queryset/#custom-query","text":"To use the custom queries you have to change the meta.manager class for a Model .","title":"Custom Query"},{"location":"queryset/#how-to-add-custom-manager-class-with-model","text":"from flask_tortoise import Tortoise , fields from flask_tortoise.models import Manager db = Tortoise () class Users ( db . Model ): id = fields . IntField ( pk = True ) name = fields . CharField ( 20 , null = True ) status = fields . CharField ( 20 ) class Meta : manager = Manager () the above process will add a custom manager with your model. And this custom manager will provide the extra query methods.","title":"How to add custom manager class with Model"},{"location":"queryset/#available-custom-methods","text":"","title":"Available custom methods"},{"location":"queryset/#get_or_404","text":"Fetch exactly one object matching the parameters or raise 404 not found error.","title":"get_or_404"},{"location":"queryset/#parameters","text":"args: Q functions containing constraints. Will be AND'ed. kwargs: Simple filter constraints. description: Error description.","title":"Parameters"},{"location":"queryset/#example","text":"@app . get ( \"/data\" ) async def get_data (): pk = 17 user = await Users . get_or_404 ( pk = pk , description = f \"user object not found at ID: { pk } \" ) return jsonify ( name = str ( user ))","title":"Example:"},{"location":"queryset/#first_or_404","text":"Like method first but aborts with 404 if not found instead of returning None .","title":"first_or_404"},{"location":"queryset/#parameters_1","text":"args: Q functions containing constraints. Will be AND'ed. kwargs: Simple filter constraints.","title":"Parameters"},{"location":"queryset/#examples","text":"@app . get ( \"/data-1\" ) async def get_data_one (): pk = 17 user = await Users . first_or_404 ( pk = pk , description = f \"user object not found at ID: { pk } \" ) return jsonify ( name = str ( user ))","title":"Examples"},{"location":"queryset/#pagination","text":"The pagination support just like the flask-sqlalchemy . This features is still under development. Jinja2 requires teh support of async functions to do this.","title":"pagination"},{"location":"tutorial/","text":"Tutorial \u00b6 Introduction \u00b6 The basic introdunction provides you a basic understanding of the Flask-Tortoise module. Primary entity of tortoise is flask_tortoise.models.Model. You can start writing models like this: from flask_tortoise.models import Tortoise , fields db : \"Tortoise\" = Tortoise () class Tournament ( db . Model ): # Defining `id` field is optional, it will be defined automatically # if you haven't done it yourself id = fields . IntField ( pk = True ) name = fields . CharField ( max_length = 255 ) # Defining ``__str__`` is also optional, but gives you pretty # represent of model in debugger and interpreter def __str__ ( self ): return self . name class Event ( db . Model ): id = fields . IntField ( pk = True ) name = fields . CharField ( max_length = 255 ) # References to other models are defined in format # \"{app_name}.{model_name}\" - where {app_name} is defined in tortoise config tournament = fields . ForeignKeyField ( 'models.Tournament' , related_name = 'events' ) participants = fields . ManyToManyField ( 'models.Team' , related_name = 'events' , through = 'event_team' ) def __str__ ( self ): return self . name class Team ( db . Model ): id = fields . IntField ( pk = True ) name = fields . CharField ( max_length = 255 ) def __str__ ( self ): return self . name After you defined all your models, tortoise needs you to init them, in order to create backward relations between models and match your db client with appropriate models. You can do it like this: from .models import * from flask import Flask app = Flask ( __name__ ) db . init_app ( app ) if __name__ == '__main__' : app . run () Here init_app method will connect the flask application with the Tortoise ORM . Tortoise is the asynchronous based database. So the database connection must to close on every request end. So this module will initialize the Tortoise ORM before on every request and close it after the reqyest end. After that you can start using your models: # Create instance by save tournament = Tournament ( name = 'New Tournament' ) await tournament . save () # Or by .create() await Event . create ( name = 'Without participants' , tournament = tournament ) event = await Event . create ( name = 'Test' , tournament = tournament ) participants = [] for i in range ( 2 ): team = await Team . create ( name = 'Team {} ' . format ( i + 1 )) participants . append ( team ) # M2M Relationship management is quite straightforward # (look for methods .remove(...) and .clear()) await event . participants . add ( * participants ) # You can query related entity just with async for async for team in event . participants : pass # After making related query you can iterate with regular for, # which can be extremely convenient for using with other packages, # for example some kind of serializers with nested support for team in event . participants : pass # Or you can make preemptive call to fetch related objects, # so you can work with related objects immediately selected_events = await Event . filter ( participants = participants [ 0 ] . id ) . prefetch_related ( 'participants' , 'tournament' ) for event in selected_events : print ( event . tournament . name ) print ([ t . name for t in event . participants ]) # Tortoise ORM supports variable depth of prefetching related entities # This will fetch all events for team and in those team tournament will be prefetched await Team . all () . prefetch_related ( 'events__tournament' ) # You can filter and order by related models too await Tournament . filter ( events__name__in = [ 'Test' , 'Prod' ] ) . order_by ( '-events__participants__name' ) . distinct () Note: For more please visit the official documentation of Tortoise ORM at: https://tortoise-orm.readthedocs.io/en/latest/getting_started.html#tutorial","title":"Tutorial"},{"location":"tutorial/#tutorial","text":"","title":"Tutorial"},{"location":"tutorial/#introduction","text":"The basic introdunction provides you a basic understanding of the Flask-Tortoise module. Primary entity of tortoise is flask_tortoise.models.Model. You can start writing models like this: from flask_tortoise.models import Tortoise , fields db : \"Tortoise\" = Tortoise () class Tournament ( db . Model ): # Defining `id` field is optional, it will be defined automatically # if you haven't done it yourself id = fields . IntField ( pk = True ) name = fields . CharField ( max_length = 255 ) # Defining ``__str__`` is also optional, but gives you pretty # represent of model in debugger and interpreter def __str__ ( self ): return self . name class Event ( db . Model ): id = fields . IntField ( pk = True ) name = fields . CharField ( max_length = 255 ) # References to other models are defined in format # \"{app_name}.{model_name}\" - where {app_name} is defined in tortoise config tournament = fields . ForeignKeyField ( 'models.Tournament' , related_name = 'events' ) participants = fields . ManyToManyField ( 'models.Team' , related_name = 'events' , through = 'event_team' ) def __str__ ( self ): return self . name class Team ( db . Model ): id = fields . IntField ( pk = True ) name = fields . CharField ( max_length = 255 ) def __str__ ( self ): return self . name After you defined all your models, tortoise needs you to init them, in order to create backward relations between models and match your db client with appropriate models. You can do it like this: from .models import * from flask import Flask app = Flask ( __name__ ) db . init_app ( app ) if __name__ == '__main__' : app . run () Here init_app method will connect the flask application with the Tortoise ORM . Tortoise is the asynchronous based database. So the database connection must to close on every request end. So this module will initialize the Tortoise ORM before on every request and close it after the reqyest end. After that you can start using your models: # Create instance by save tournament = Tournament ( name = 'New Tournament' ) await tournament . save () # Or by .create() await Event . create ( name = 'Without participants' , tournament = tournament ) event = await Event . create ( name = 'Test' , tournament = tournament ) participants = [] for i in range ( 2 ): team = await Team . create ( name = 'Team {} ' . format ( i + 1 )) participants . append ( team ) # M2M Relationship management is quite straightforward # (look for methods .remove(...) and .clear()) await event . participants . add ( * participants ) # You can query related entity just with async for async for team in event . participants : pass # After making related query you can iterate with regular for, # which can be extremely convenient for using with other packages, # for example some kind of serializers with nested support for team in event . participants : pass # Or you can make preemptive call to fetch related objects, # so you can work with related objects immediately selected_events = await Event . filter ( participants = participants [ 0 ] . id ) . prefetch_related ( 'participants' , 'tournament' ) for event in selected_events : print ( event . tournament . name ) print ([ t . name for t in event . participants ]) # Tortoise ORM supports variable depth of prefetching related entities # This will fetch all events for team and in those team tournament will be prefetched await Team . all () . prefetch_related ( 'events__tournament' ) # You can filter and order by related models too await Tournament . filter ( events__name__in = [ 'Test' , 'Prod' ] ) . order_by ( '-events__participants__name' ) . distinct () Note: For more please visit the official documentation of Tortoise ORM at: https://tortoise-orm.readthedocs.io/en/latest/getting_started.html#tutorial","title":"Introduction"}]}